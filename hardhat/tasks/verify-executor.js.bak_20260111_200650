import { keccak256, isAddress, getAddress, zeroAddress, hexToBytes } from "viem";

/**
 * Strip Solidity CBOR metadata from the end of deployed bytecode.
 * Solidity appends: <runtime><cbor_metadata><2 bytes: metadata_length>
 *
 * The last 2 bytes (4 hex chars) encode metadata length in bytes.
 * Total trailer bytes = metadataLen + 2.
 */
function stripSolcMetadata(hex) {
  if (!hex || hex === "0x") return hex;
  const h = hex.startsWith("0x") ? hex.slice(2) : hex;
  if (h.length < 4) return hex;

  const lenHex = h.slice(-4);
  const metaLen = parseInt(lenHex, 16);
  if (!Number.isFinite(metaLen) || metaLen <= 0) return hex;

  const trailerBytes = metaLen + 2;
  const trailerHexChars = trailerBytes * 2;
  if (trailerHexChars >= h.length) return hex;

  const stripped = h.slice(0, h.length - trailerHexChars);
  return "0x" + stripped;
}

export default async function (taskArgs, hre) {
  const expectedChainId = 42161;

  const addrRaw = (taskArgs.address ?? process.env.EXECUTOR_ADDRESS ?? "").trim();
  if (!addrRaw) throw new Error("Missing --address or EXECUTOR_ADDRESS");
  if (!isAddress(addrRaw)) throw new Error(`Invalid address: ${addrRaw}`);

  const address = getAddress(addrRaw);

  const { viem } = await hre.network.connect();
  const publicClient = await viem.getPublicClient();

  const chainId = await publicClient.getChainId();
  if (chainId !== expectedChainId) {
    throw new Error(`Wrong chainId. Expected ${expectedChainId} (Arbitrum One), got ${chainId}`);
  }

  const onchainCode = await publicClient.getBytecode({ address });
  if (!onchainCode || onchainCode === "0x") {
    throw new Error(`No bytecode at ${address}. Not a contract or wrong address/network.`);
  }

  const artifact = await hre.artifacts.readArtifact("LiquidationExecutor");
  const localDeployedBytecode =
    artifact.deployedBytecode ??
    artifact.deployedBytecode?.object ??
    artifact.evm?.deployedBytecode?.object ??
    "";

  if (!localDeployedBytecode || localDeployedBytecode === "0x") {
    throw new Error("Could not find deployed bytecode in artifact (LiquidationExecutor).");
  }

  const onchainHash = keccak256(hexToBytes(onchainCode));
  const localHash = keccak256(hexToBytes(localDeployedBytecode));

  const onchainStripped = stripSolcMetadata(onchainCode);
  const localStripped = stripSolcMetadata(localDeployedBytecode);

  const onchainStrippedHash = keccak256(hexToBytes(onchainStripped));
  const localStrippedHash = keccak256(hexToBytes(localStripped));

  console.log("== On-chain verification ==");
  console.log(`network.chainId: ${chainId}`);
  console.log(`contract: ${address}`);

  console.log("== Raw bytecode hashes ==");
  console.log(`onchain.keccak256: ${onchainHash}`);
  console.log(`local.keccak256:   ${localHash}`);
  console.log(`len.onchain: ${onchainCode.length} hex chars`);
  console.log(`len.local:   ${localDeployedBytecode.length} hex chars`);

  console.log("== Stripped (no metadata) bytecode hashes ==");
  console.log(`onchain.stripped.keccak256: ${onchainStrippedHash}`);
  console.log(`local.stripped.keccak256:   ${localStrippedHash}`);
  console.log(`len.onchain.stripped: ${onchainStripped.length} hex chars`);
  console.log(`len.local.stripped:   ${localStripped.length} hex chars`);

  if (onchainStrippedHash !== localStrippedHash) {
    throw new Error("Bytecode mismatch (metadata-stripped): local artifact does not match on-chain runtime.");
  }

  if (onchainHash !== localHash) {
    console.log("NOTE: Raw hash mismatch but stripped hash matches => only metadata differs. This is acceptable.");
  } else {
    console.log("OK: Raw hash matches too.");
  }

  // Try common getters if they exist in ABI
  const abi = artifact.abi ?? [];
  const hasFn = (name) =>
    abi.some((x) => x?.type === "function" && x?.name === name && (x?.inputs?.length ?? 0) === 0);

  const read0 = async (fnName) => {
    try {
      const result = await publicClient.readContract({ address, abi, functionName: fnName, args: [] });
      return result;
    } catch {
      return undefined;
    }
  };

  const candidates = ["owner", "treasury", "AAVE_POOL", "MORPHO", "SWAP_ROUTER"];
  console.log("== Getter probe ==");
  for (const fn of candidates) {
    if (!hasFn(fn)) continue;
    const v = await read0(fn);
    if (typeof v === "string" && v === zeroAddress) {
      throw new Error(`Guardrail failed: ${fn}() returned zero address`);
    }
    console.log(`${fn}():`, v);
  }

  console.log("Done.");
}
